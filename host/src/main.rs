use std::collections::HashMap;
use anyhow::Result;
use clap::{Parser, Subcommand};
use client_sdk::helpers::risc0::Risc0Prover;
use contract::ImageState;
use contract::ImageAction;
use sdk::api::APIRegisterContract;
use sdk::BlobTransaction;
use sdk::ProofTransaction;
use sdk::{ContractInput, Digestable, HyleContract};
use warp::{Filter, Rejection, Reply};
use std::sync::Arc;
use tokio::sync::Mutex;
use serde::{Deserialize, Serialize};
use warp::reject::Reject;
use std::fmt;


// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{GUEST_ELF, GUEST_ID};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    #[arg(long, default_value = "http://localhost:4321")]
    pub host: String,

    #[arg(long, default_value = "image_state")]
    pub contract_name: String,
}

#[derive(Debug)]
struct CustomRejection(anyhow::Error);

impl Reject for CustomRejection {}

impl fmt::Display for CustomRejection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Deserialize)]
struct RegisterImageRequest {
    image_hash: String,
    image_signature: String,
    owner_pk: String,
}

#[derive(Deserialize)]
struct VerifyOriginalImageRequest {
    image_hash: String,
}

#[derive(Deserialize)]
struct RegisterEditRequest {
    original_image_hash: String,
    edited_image_hash: String,
    original_edit_signature: String,
}

#[derive(Deserialize)]
struct AddPublisherRequest {
    original_image_hash: String,
    original_image_signature: String,
    publisher_pk: String,
}

#[derive(Subcommand)]
enum Commands {
    Server {},
    RegisterContract {},
    RegisterImage {
        image_hash: String,
        image_signature: String,
        owner_pk:String,
    },
    VerifyOriginalImage { image_hash: String },
    RegisterEdit{original_image_hash: String, edited_image_hash: String, original_edit_signature: String},
    AddPublisher { original_image_hash: String, original_image_signature: String, publisher_pk: String },


}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    let host = cli.host.clone();

    // Client to send requests to the node
    let client = client_sdk::rest_client::NodeApiHttpClient::new(host.clone())?;
    let contract_name = &cli.contract_name;


    // Will be used to generate zkProof of the execution.
    let prover = Risc0Prover::new(GUEST_ELF);

    // This dummy example doesn't uses identities. But there are required fields & validation.
    let identity = format!("none.{}", contract_name);

    match cli.command {
        Commands::Server {} => {
            // Client to send requests to the node
            let client = Arc::new(client_sdk::rest_client::NodeApiHttpClient::new(host)?);
            let contract_name = cli.contract_name.clone();

            // Will be used to generate zkProof of the execution.
            let prover = Arc::new(Risc0Prover::new(GUEST_ELF));

            // This dummy example doesn't uses identities. But there are required fields & validation.
            let identity = format!("none.{}", contract_name);

            let register_image_route = warp::post()
                .and(warp::path("register_image"))
                .and(warp::body::json())
                .and_then({
                    let client = Arc::clone(&client);
                    let contract_name = contract_name.clone();
                    let prover = Arc::clone(&prover);
                    let identity = identity.clone();
                    move |req: RegisterImageRequest| {
                        let client = Arc::clone(&client);
                        let contract_name = contract_name.clone();
                        let prover = Arc::clone(&prover);
                        let identity = identity.clone();
                        async move {
                            let mut initial_state: ImageState = client
                                .get_contract(&contract_name.clone().into())
                                .await
                                .unwrap()
                                .state
                                .into();

                            let action = ImageAction::RegisterImage {
                                image_hash: req.image_hash,
                                image_signature: req.image_signature,
                                owner_pk: req.owner_pk,
                            };
                            let blobs = vec![action.as_blob(&contract_name)];
                            let blob_tx = BlobTransaction::new(identity.clone(), blobs.clone());

                            let blob_tx_hash = client.send_tx_blob(&blob_tx).await.unwrap();
                            println!("âœ… Blob tx sent. Tx hash: {}", blob_tx_hash);

                            let inputs = ContractInput {
                                state: initial_state.as_bytes().unwrap(),
                                identity: identity.clone().into(),
                                tx_hash: blob_tx_hash,
                                private_input: vec![],
                                tx_ctx: None,
                                blobs: blobs.clone(),
                                index: sdk::BlobIndex(0),
                            };

                            let (program_outputs, _, _) = initial_state.execute(&inputs).unwrap();
                            println!("ðŸš€ Executed: {}", program_outputs);


                            let proof = prover.prove(inputs).await.unwrap();

                            let proof_tx = ProofTransaction {
                                proof,
                                contract_name: contract_name.clone().into(),
                            };

                            let proof_tx_hash = client.send_tx_proof(&proof_tx).await.unwrap();
                            println!("âœ… Proof tx sent. Tx hash: {}", proof_tx_hash);

                            Ok::<_, warp::Rejection>(warp::reply::json(&program_outputs))
                        }
                    }
                });

            #[derive(Serialize)]
            struct IsOriginalResponse {
                is_original: bool,
            }


            let verify_original_image_route = warp::post()
                .and(warp::path("verify_original_image"))
                .and(warp::body::json())
                .and_then({
                    let client = Arc::clone(&client);
                    let contract_name = contract_name.clone();
                    move |req: VerifyOriginalImageRequest| {
                        let client = Arc::clone(&client);
                        let contract_name = contract_name.clone();
                        async move {
                            let initial_state: ImageState = client
                                .get_contract(&contract_name.clone().into())
                                .await
                                .unwrap()
                                .state
                                .into();
                            let is_original_result = initial_state.is_original_image(req.image_hash);
                            match is_original_result {
                                Ok(is_original) => {
                                    println!("âœ… Is original Image ?: {:?}", is_original);
                                    let response = IsOriginalResponse { is_original };
                                    Ok::<_, warp::Rejection>(warp::reply::json(&response))
                                }
                                Err(e) => {
                                    eprintln!("Failed to verify original image: {:?}", e);
                                    Err(warp::reject::custom(CustomRejection(anyhow::anyhow!(e))))
                                }
                            }
                        }
                    }
                });


            let register_edit_route = warp::post()
                .and(warp::path("register_edit"))
                .and(warp::body::json())
                .and_then({
                    let client = Arc::clone(&client);
                    let contract_name = contract_name.clone();
                    let prover = Arc::clone(&prover);
                    let identity = identity.clone();
                    move |req: RegisterEditRequest| {
                        let client = Arc::clone(&client);
                        let contract_name = contract_name.clone();
                        let prover = Arc::clone(&prover);
                        let identity = identity.clone();
                        async move {
                            let mut initial_state: ImageState = client
                                .get_contract(&contract_name.clone().into())
                                .await
                                .unwrap()
                                .state
                                .into();

                            let action = ImageAction::RegisterEdit {
                                original_image_hash: req.original_image_hash,
                                edited_image_hash: req.edited_image_hash,
                                original_edit_signature: req.original_edit_signature,
                            };
                            let blobs = vec![action.as_blob(&contract_name)];
                            let blob_tx = BlobTransaction::new(identity.clone(), blobs.clone());

                            let blob_tx_hash = client.send_tx_blob(&blob_tx).await.unwrap();
                            println!("âœ… Blob tx sent. Tx hash: {}", blob_tx_hash);

                            let inputs = ContractInput {
                                state: initial_state.as_bytes().unwrap(),
                                identity: identity.clone().into(),
                                tx_hash: blob_tx_hash,
                                private_input: vec![],
                                tx_ctx: None,
                                blobs: blobs.clone(),
                                index: sdk::BlobIndex(0),
                            };

                            let (program_outputs, _, _) = initial_state.execute(&inputs).unwrap();
                            println!("ðŸš€ Executed: {}", program_outputs);

                            let proof = prover.prove(inputs).await.unwrap();

                            let proof_tx = ProofTransaction {
                                proof,
                                contract_name: contract_name.clone().into(),
                            };

                            let proof_tx_hash = client.send_tx_proof(&proof_tx).await.unwrap();
                            println!("âœ… Proof tx sent. Tx hash: {}", proof_tx_hash);

                            Ok::<_, warp::Rejection>(warp::reply::json(&program_outputs))
                        }
                    }
                });

            let add_publisher_route = warp::post()
                .and(warp::path("add_publisher"))
                .and(warp::body::json())
                .and_then({
                    let client = Arc::clone(&client);
                    let contract_name = contract_name.clone();
                    let prover = Arc::clone(&prover);
                    let identity = identity.clone();
                    move |req: AddPublisherRequest| {
                        let client = Arc::clone(&client);
                        let contract_name = contract_name.clone();
                        let prover = Arc::clone(&prover);
                        let identity = identity.clone();
                        async move {
                            let mut initial_state: ImageState = client
                                .get_contract(&contract_name.clone().into())
                                .await
                                .unwrap()
                                .state
                                .into();

                            let action = ImageAction::AddPublisher {
                                original_image_hash: req.original_image_hash,
                                original_image_signature: req.original_image_signature,
                                publisher_pk: req.publisher_pk,
                            };
                            let blobs = vec![action.as_blob(&contract_name)];
                            let blob_tx = BlobTransaction::new(identity.clone(), blobs.clone());

                            let blob_tx_hash = client.send_tx_blob(&blob_tx).await.unwrap();
                            println!("âœ… Blob tx sent. Tx hash: {}", blob_tx_hash);

                            let inputs = ContractInput {
                                state: initial_state.as_bytes().unwrap(),
                                identity: identity.clone().into(),
                                tx_hash: blob_tx_hash,
                                private_input: vec![],
                                tx_ctx: None,
                                blobs: blobs.clone(),
                                index: sdk::BlobIndex(0),
                            };

                            let (program_outputs, _, _) = initial_state.execute(&inputs).unwrap();
                            println!("ðŸš€ Executed: {}", program_outputs);

                            let proof = prover.prove(inputs).await.unwrap();

                            let proof_tx = ProofTransaction {
                                proof,
                                contract_name: contract_name.clone().into(),
                            };

                            let proof_tx_hash = client.send_tx_proof(&proof_tx).await.unwrap();
                            println!("âœ… Proof tx sent. Tx hash: {}", proof_tx_hash);

                            Ok::<_, warp::Rejection>(warp::reply::json(&program_outputs))
                        }
                    }
                });

            let cors = warp::cors()
                .allow_any_origin()
                .allow_methods(vec!["POST", "GET", "PUT", "DELETE"])
                .allow_headers(vec!["Content-Type", "Authorization"]);

            let routes = register_image_route.or(verify_original_image_route).or(add_publisher_route).or(register_edit_route).with(cors);



            warp::serve(routes).run(([127, 0, 0, 1], 3030)).await;



        }
        Commands::RegisterContract {} => {
            // Build initial state of contract
            let initial_state = ImageState { hash_map: HashMap::new()};

            // Send the transaction to register the contract
            let res = client
                .register_contract(&APIRegisterContract {
                    verifier: "risc0".into(),
                    program_id: sdk::ProgramId(sdk::to_u8_array(&GUEST_ID).to_vec()),
                    state_digest: initial_state.as_digest(),
                    contract_name: contract_name.clone().into(),
                })
                .await?;
            println!("âœ… Register contract tx sent. Tx hash: {}", res);
        }
        Commands::RegisterImage {image_hash, image_signature, owner_pk} => {
            // Fetch the initial state from the node
            let mut initial_state: ImageState = client
                .get_contract(&contract_name.clone().into())
                .await
                .unwrap()
                .state
                .into();

            // ----
            // Build the blob transaction
            // ----
            let action = ImageAction::RegisterImage {image_hash, image_signature, owner_pk};
            let blobs = vec![action.as_blob(contract_name)];
            let blob_tx = BlobTransaction::new(identity.clone(), blobs.clone());

            // Send the blob transaction
            let blob_tx_hash = client.send_tx_blob(&blob_tx).await.unwrap();
            println!("âœ… Blob tx sent. Tx hash: {}", blob_tx_hash);

            // ----
            // Prove the state transition
            // ----

            // Build the contract input
            let inputs = ContractInput {
                state: initial_state.as_bytes().unwrap(),
                identity: identity.clone().into(),
                tx_hash: blob_tx_hash,
                private_input: vec![],
                tx_ctx: None,
                blobs: blobs.clone(),
                index: sdk::BlobIndex(0),
            };

            let (program_outputs, _, _) = initial_state.execute(&inputs).unwrap();
            println!("ðŸš€ Executed: {}", program_outputs);

            // Generate the zk proof
            let proof = prover.prove(inputs).await.unwrap();

            // Build the Proof transaction
            let proof_tx = ProofTransaction {
                proof,
                contract_name: contract_name.clone().into(),
            };

            // Send the proof transaction
            let proof_tx_hash = client.send_tx_proof(&proof_tx).await.unwrap();
            println!("âœ… Proof tx sent. Tx hash: {}", proof_tx_hash);
        }
        Commands::VerifyOriginalImage {image_hash} => {
            let initial_state: ImageState = client
                .get_contract(&contract_name.clone().into())
                .await
                .unwrap()
                .state
                .into();
            let is_original = initial_state.is_original_image(image_hash);
            println!("âœ… Is original Image ?: {:?}", is_original);
        }
        Commands::RegisterEdit {original_image_hash, edited_image_hash,original_edit_signature} =>{
            // Fetch the initial state from the node
            let mut initial_state: ImageState = client
                .get_contract(&contract_name.clone().into())
                .await
                .unwrap()
                .state
                .into();

            // ----
            // Build the blob transaction
            // ----
            let action = ImageAction::RegisterEdit {original_image_hash, edited_image_hash, original_edit_signature};
            let blobs = vec![action.as_blob(contract_name)];
            let blob_tx = BlobTransaction::new(identity.clone(), blobs.clone());

            // Send the blob transaction
            let blob_tx_hash = client.send_tx_blob(&blob_tx).await.unwrap();
            println!("âœ… Blob tx sent. Tx hash: {}", blob_tx_hash);

            // ----
            // Prove the state transition
            // ----

            // Build the contract input
            let inputs = ContractInput {
                state: initial_state.as_bytes().unwrap(),
                identity: identity.clone().into(),
                tx_hash: blob_tx_hash,
                private_input: vec![],
                tx_ctx: None,
                blobs: blobs.clone(),
                index: sdk::BlobIndex(0),
            };

            let (program_outputs, _, _) = initial_state.execute(&inputs).unwrap();
            println!("ðŸš€ Executed: {}", program_outputs);

            // Generate the zk proof
            let proof = prover.prove(inputs).await.unwrap();

            // Build the Proof transaction
            let proof_tx = ProofTransaction {
                proof,
                contract_name: contract_name.clone().into(),
            };

            // Send the proof transaction
            let proof_tx_hash = client.send_tx_proof(&proof_tx).await.unwrap();
            println!("âœ… Proof tx sent. Tx hash: {}", proof_tx_hash);
        }
        Commands::AddPublisher {original_image_hash, original_image_signature, publisher_pk} => {
            // Fetch the initial state from the node
            let mut initial_state: ImageState = client
                .get_contract(&contract_name.clone().into())
                .await
                .unwrap()
                .state
                .into();

            // ----
            // Build the blob transaction
            // ----
            let action = ImageAction::AddPublisher {original_image_hash, original_image_signature, publisher_pk};
            let blobs = vec![action.as_blob(contract_name)];
            let blob_tx = BlobTransaction::new(identity.clone(), blobs.clone());

            // Send the blob transaction
            let blob_tx_hash = client.send_tx_blob(&blob_tx).await.unwrap();
            println!("âœ… Blob tx sent. Tx hash: {}", blob_tx_hash);

            // ----
            // Prove the state transition
            // ----

            // Build the contract input
            let inputs = ContractInput {
                state: initial_state.as_bytes().unwrap(),
                identity: identity.clone().into(),
                tx_hash: blob_tx_hash,
                private_input: vec![],
                tx_ctx: None,
                blobs: blobs.clone(),
                index: sdk::BlobIndex(0),
            };

            let (program_outputs, _, _) = initial_state.execute(&inputs).unwrap();
            println!("ðŸš€ Executed: {}", program_outputs);

            // Generate the zk proof
            let proof = prover.prove(inputs).await.unwrap();

            // Build the Proof transaction
            let proof_tx = ProofTransaction {
                proof,
                contract_name: contract_name.clone().into(),
            };

            // Send the proof transaction
            let proof_tx_hash = client.send_tx_proof(&proof_tx).await.unwrap();
            println!("âœ… Proof tx sent. Tx hash: {}", proof_tx_hash);
        }
    }

    Ok(())
}